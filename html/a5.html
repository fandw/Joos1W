<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>
CS 444/644 - Compiler Construction (Winter 2017) - Assignment 5
</title>
</head>
<body>
<h1>
CS 444/644 - Compiler Construction (Winter 2017) - Assignment 5
</h1>

<!-- <font color=red>Corrections since the assignment was posted are in red.</font> -->
<p>
For this last assignment, you will make your compiler generate
i386 assembly language (32-bit mode).
<p>
As in previous assignments,
you must hand in to Marmoset a <tt>.zip</tt> archive containing
your source code. The <tt>.zip</tt> file must contain a file called
<tt>Makefile</tt>. Marmoset will run <tt>make</tt> on this <tt>Makefile</tt>
to compile your compiler. The <tt>Makefile</tt> must generate an executable
(binary or shell script) called <tt>joosc</tt>.
The <tt>joosc</tt> executable must accept multiple
filenames as arguments. All of the files listed on the <tt>joosc</tt>
command line, and <b>only</b> those files, are considered part of
the program being compiled.
<p>
Unlike <tt>javac</tt> and unlike the dOvs version of Joos, your <tt>joosc</tt>
compiler should not look for classes in <tt>.class</tt> files on the
<tt>CLASSPATH</tt>; it should read <b>only</b> the Joos 1W source files
listed on the command line. This means that all classes, including
classes such as <tt>java.lang.Object</tt>, must be available in
source form and must be specified on the <tt>joosc</tt> command line.
Unlike <tt>javac</tt>, Joos does not care what directory a source
file is in (i.e. it does not require the directory structure
of the source code to match the package structure).
However, the class declared in a file must still have the same name
as the filename.
For example, Java would require that the class <tt>java.lang.Object</tt>
be declared in the file <tt>Object.java</tt> in the directory
<tt>java.lang</tt>, whereas Joos only requires the file to
be named <tt>Object.java</tt>, but otherwise allows it to
be in any directory.
<p>
For the purposes of this course, a minimalist version of the
Java standard library is provided. This library can be found
in the <tt>linux.student.cs</tt> environment in the directory
<tt>/u/cs444/pub/stdlib/5.0</tt>. Marmoset will include all
files in this library on the <tt>joosc</tt> command line for
every test, in addition to other source file(s) specific to that
test. The following versioning scheme is used to make it possible
to correct errors and/or to extend the library for future assignments
(although we aim to minimize the number of changes that will be required).
The 5 in the directory name refers to Assignment 5, and the 0
is the first version of the library. Any corrections to the Assignment 5
version of the library will appear in the directories <tt>5.1</tt>,
<tt>5.2</tt>, etc.
<p>
As in previous assignments,
<tt>joosc</tt> should process the Joos 1W files given on the command line,
produce appropriate diagnostic messages on standard error,
and exit with one of the following Unix return codes:
<ul>
    <li>0: the input file is valid Joos 1W
    <li>42: the input file is <b>not</b> valid Joos 1W
    <li>any other value: your compiler crashed
</ul>
<p>
If the input program is valid Joos 1W, your compiler should output,
into the subdirectory <tt>output</tt> of the current working directory,
one or more files with the extension <tt>.s</tt> containing the assembly
language code implementing the program. It is recommended that the
code implementing each class be generated into a separate <tt>.s</tt>
file. You may assume that the <tt>output</tt> directory exists
before your compiler runs, and that the directory is empty.
After your compiler runs, each of the <tt>.s</tt> files in the
directory will be assembled with the command:
<pre>
/u/cs444/bin/nasm -O1 -f elf -g -F dwarf filename.s
</pre>
After all of the files are successfully assembled, the
file <tt>runtime.s</tt> from the standard library (see below for description)
will also be assembled and placed in the <tt>output</tt> directory.
Then, all of the <tt>.o</tt> files generated by <tt>nasm</tt> in the
<tt>output</tt> directory will be linked using the command:
<pre>
ld -melf_i386 -o main output/*.o
</pre>
Finally, the generated executable <tt>main</tt> will be executed.
<p>
Your <tt>joosc</tt> compiler, the assembler and linker, and your final
<tt>main</tt> executable will be run on one of the Linux
CPU servers (e.g. <tt>linux028.student.cs</tt>).
<p>
One of the generated <tt>.s</tt> files must define the global symbol
<tt>_start</tt>:
<pre>
global _start
_start:
</pre>
When your program is run, execution will start from this point.
<p>
Unlike in Java, the first method that begins executing is not
<tt>static void main(String[])</tt>, but <tt>static int test()</tt>.
All of the test inputs will have such a method. The class containing
the <tt>test</tt> method will be listed first on the 
<tt>joosc</tt>
command line,
before any other compilation units.
The code that you generate
at <tt>_start</tt> should initialize all static fields,
then call this method. 
When the method returns with return value <i>x</i>,
your program should exit with exit code <i>x</i> using the
<tt>sys_exit</tt> system call. To execute this system call,
load the value 1 (indicating <tt>sys_exit</tt>) into register
eax, load the exit code into register ebx, then execute the
instruction <tt>int 0x80</tt>.
<p>
Java specifies a very precise but complicated order in which
static fields must be initialized (JLS 12.4). For Joos, the order is
specified by the following rules:
<ul>
    <li>All static fields must be initialized before the startup
    code calls the <tt>static int test()</tt> method.
    <li>Static fields within the same class must be initialized
    in the order in which they appear in the class.
    <li>Static fields in different classes can be initialized
    in any order.
</ul>
Note that Java and Joos require that any field without an explicit
initializer be initialized to the value <tt>false</tt>, <tt>0</tt>,
or <tt>null</tt>, depending on its declared type.
<p>
The <tt>runtime.s</tt> file included with the standard library
contains several utilities that are likely to be useful.
<ul>
    <li>The function <tt>__malloc</tt> allocates a number of bytes of
memory. The number of bytes to be allocated must be in the register 
eax before executing the instruction <tt>call __malloc</tt>. The
address of the beginning of the allocated memory can be found
on register eax after the call. There is no provision for freeing
allocated memory; you should not need it for the simple programs
that we will be testing with.
    <li>The function <tt>__exception</tt> ends the program with exit
code 13. You should call this function in any situation in which the
equivalent Java code would throw an exception, such as a failed
null check, array bounds check, or cast check.
    <li>The function <tt>NATIVEjava.io.OutputStream.nativeWrite</tt>
is an implementation of the native method <tt>nativeWrite</tt>
found in the <tt>java.io.OutputStream</tt> class of the standard
library. The method writes the low-order byte of its parameter
to the standard output. This method is used as the basis of
more sophisticated output methods in the standard library
such as <tt>System.out.println()</tt>.
In general, you should translate the call of any native
method into a call to the symbol that begins with the string
<tt>NATIVE</tt>, followed by the canonical name of the class
containing the native method, followed by a dot (<tt>.</tt>),
followed by the name of the native method. Although no native
methods other than <tt>nativeWrite</tt> will appear in the tests,
you can use this mechanism in your own tests to implement additional 
interaction between your Joos code and the operating system.
Recall that in Joos 1W, all native methods must be static,
must take a single argument of type <tt>int</tt>, and must
return a value of type <tt>int</tt>. The parameter passing
conventions for native methods are the following. The argument must
be placed in the register eax prior to calling the native
method, and the return value can be found in the register
eax after the native method returns.
</ul>
<p>
For the convenience of groups doing their development on Windows,
a former student has made available <a href=WinRuntime.s>a Windows
translation of <tt>runtime.s</tt></a>. You may use this version during development.
Marmoset will test your compiler on the <tt>linux.student.cs</tt>
servers with the <tt>runtime.s</tt> file that is included with the
Joos standard library.
<p>
Before starting to implement this assignment, it is strongly recommended
that you meet with your group to design and agree on conventions for 
<ul>
    <li>parameter passing,
    <li>local variable storage,
    <li>object layout, and
    <li>naming of labels for method implementations and data.
</ul>
It is recommended that you
document these conventions at this stage,
and include this documentation
in the design document that you hand in.
It is suggested that you modularize the implementation of these
conventions in dedicated modules in your compiler, to ensure consistency
between the different parts of your compiler that rely on the
conventions.
<p>
The Marmoset tests for this assignment take several minutes to run.
Do not submit more than one submission at a time to Marmoset.
If Marmoset reports that your previous submission has not been tested
yet, do not submit another one. Denial-of-service attacks on Marmoset
will result in disciplinary action.
<p>
Submit to Marmoset a PDF document of no more than five pages explaining
the design decisions you made in completing the assignment.
As in previous assignments,
the document should be
organized to enable someone unfamiliar with your code to understand the
structure of your compiler. In the document, discuss
challenges that you encountered and how you tried to overcome them in
your design and implementation. Also explain the testing that you
did before submitting to Marmoset.
<p>
The document will be hand-marked, with 2/3 of the marks for
organization, clarity, and style, and 1/3 of the marks for
technical content.
<p>
According to the late policy posted on the course web page,
design documents submitted after the assignment deadline
will not be marked and will receive a mark of <b>zero</b>.
If you cannot finish the
assignment by the deadline, submit what you have by the deadline,
and explain any unfinished parts in your design document.

</body>
</html>
